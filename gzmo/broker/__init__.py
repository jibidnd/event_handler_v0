"""Base broker class.
"""

import abc
import uuid
import threading
from decimal import Decimal

import zmq

from .. import event_handler
from .. import utils
from ..utils import constants as c


class BaseBroker(event_handler.EventHandler):
    """A broker is an interface that takes orders and/or data, and return responses to orders.

    The responses can either be sent via a socket (which the receiving end will connect to),
    or be returned through a broker method.

    Attributes:
        name (str): A name for the broker.
        broker_id (str): A unique ID for the broker generated by the uuid module.
        zmq_context (zmq.Context): A zmq context on which sockets will be established.
        open_orders (dict): Dictionary of currently open orders (waiting to be filled).
        closed_orders (list): A list of filled/closed orders.
        data_address (str): If using sockets, the zmq address to receive (price) data from,
            so the broker (simulator) can know whether/how to fill an incoming order.
        order_address (str): If using sockets, the address to receive orders from.
        logging_address(str): If using sockets, the address to send logs to.
        data_socket (zmq socket): If using sockets, the socket to receive (price) data from.
        order_socket (zmq socket): If using sockets, the socket to receive orders from.
        logging_socket (zmq socket): If using sockets, the socket to send logs to.
        main_shutdown_flag (threading.Event): If threading is used, this event can be set to signal that the main session has shut down.
        shutdown_flag (threading.Event): If threading is used, this event can be set to signal the broker to shut down.
        clock (decimal.Decimal): UTC timestamp to keep track of time.
    """

    def __init__(self, name, zmq_context = None):
        """Instantiates a broker object.

        Args:
            name (str): A human readable name for the broker.
            zmq_context (zmq.Context, optional): ZMQ context on which sockets will be established. Defaults to None.
        """        
        # initialization params
        self.name = name
        self.broker_id = str(uuid.uuid1())  # Note that this shows the network address.
        self.zmq_context = zmq_context
        self.open_orders = {}               # better to refer to orders by id so we can refer to the same order even if attributes change
        self.closed_orders = []

        # Connection things
        self.data_address = None
        self.order_address = None
        self.logging_addresses = None
        self.data_socket = None
        self.order_socket = None
        self.logging_socket = None
        
        # These can be overriden for threads, but are otherwise just placeholders
        self.main_shutdown_flag = threading.Event()
        self.shutdown_flag = threading.Event()
        
        # clock to keep track of time
        self.clock = Decimal(0.00)
    
    # ----------------------------------------------------------------------------------------
    # Connections
    # ----------------------------------------------------------------------------------------
    def connect_data_socket(self, data_address):
        """Connects a socket to the specified `data_address`.

        Args:
            data_address (str): A ZMQ address string in the form of 'protocol://interface:port’.
        """
        # if new address, overwrite the current record
        self.data_address = data_address
        
        # establish a context if none provided
        if self.zmq_context is None:
            self.zmq_context = zmq.Context.Instance()
        
        # Create a data socket if none exists yet
        if not self.data_socket:
            socket = self.zmq_context.socket(zmq.SUB)
            self.data_socket = socket
        
        # subscribe to everything because we don't know what we'll need to match orders against
        self.data_socket.setsockopt(zmq.SUBSCRIBE, b'')
        self.data_socket.connect(data_address)
        
        return
    
    def connect_order_socket(self, order_address):
        """Connects a socket to the specified `order_address`.

        Args:
            order_address (str): A ZMQ address string in the form of 'protocol://interface:port’.
        """
        # if new address, overwrite the current record
        self.order_address = order_address

        # establish a context if none provided
        if self.zmq_context is None:
            self.zmq_context = zmq.Context.Instance()

        # Create a order socket if none exists yet
        if not self.order_socket:
            socket = self.zmq_context.socket(zmq.DEALER)
            # note that this broker is identified by its name
            socket.setsockopt(zmq.IDENTITY, self.name.encode())
            self.order_socket = socket
        self.order_socket.connect(order_address)

        return
    
    def connect_logging_socket(self, logging_address):
        """Connects a socket to the specified `logging_address`.

        Args:
            logging_address (str): A ZMQ address string in the form of 'protocol://interface:port’.
        """
        # if new address, add it to the list
        if logging_address not in self.logging_addresses:
            self.logging_addresses.append(logging_address)
        
        # Create a logging socket if none exists yet
        if not self.logging_socket:
            socket = self.zmq_context.socket(zmq.DEALER)
            socket.setsockopt(zmq.IDENTITY, self.broker_id.encode())
            self.logging_socket = socket
        self.logging_socket.conenct(logging_address)

        return

    # ----------------------------------------------------------------------------------------
    # Event handling
    # ----------------------------------------------------------------------------------------
    def _handle_data(self, data):
        """Class method to handle incoming data events.

        Args:
            data (dict): Event with EVENT_TYPE = 'DATA'. Likely price/market data.
        """        
        pass

    def handle_data(self, data):
        """To be overriden by instance for data-handling specific actions.

        Args:
            data (dict): Event with EVENT_TYPE = 'DATA'. Likely price/market data.
        """        
        pass
    
    def _handle_order(self, order):
        """Class method to handle an incoming order events.

        Args:
            order (dict): Event with EVENT_TYPE = 'ORDER'. Should carry order parameters
                that the broker needs to fill the order.
        """        
        order_response = self.take_order(order)
        if (order_response is not None) and (self.order_socket is not None):
            # emit the response if there is any
            order_response_packed = utils.packb(order_response)
            self.order_socket.send(order_response_packed, flags = zmq.NOBLOCK)
        return self.handle_order(order)

    def handle_order(self, order):
        """To be overriden by instance for order-handling specific actions.

        Args:
            data (dict): Event with EVENT_TYPE = 'ORDER'. Should carry order parameters
                that the broker needs to fill the order.
        """  
        pass

    @abc.abstractmethod
    def take_order(self, order):
        """Takes an incoming order. To be implemented by the concrete broker class.

        Args:
            order (dict): ORDER event.
        """        
        pass

    def run(self):
        """Processes events from sockets.

            Sequentially process events arriving at the data and order sockets.
            All *received* data are synced and processed chronologically, as indicated
            by the EVENT_TS field of the event.
        """
        # the event "queue"
        next_events = {}

        while (not self.main_shutdown_flag.is_set()) and (not self.shutdown_flag.is_set()):
            
            # get from data socket if slot is empty
            if next_events.get(c.DATA_SOCKET) is None:
                try:
                    # This is a SUB
                    topic, event_packed = self.data_socket.recv_multipart(zmq.NOBLOCK)
                    next_events[c.DATA_SOCKET] = utils.unpackb(event_packed)
                except zmq.ZMQError as exc:
                    # nothing to get
                    if exc.errno == zmq.EAGAIN:
                        pass
                    else:
                        raise
            
            # get from order socket if slot is empty
            if next_events.get(c.ORDER_SOCKET) is None:
                try:
                    # This is a dealer
                    order_packed = self.order_socket.recv(zmq.NOBLOCK)
                    order_unpacked = utils.unpackb(order_packed)
                    next_events[c.ORDER_SOCKET] = order_unpacked
                except zmq.ZMQError as exc:
                    # nothing to get
                    if exc.errno == zmq.EAGAIN:
                        pass
                    else:
                        raise

            # Sort the events
            if len(next_events) > 0:
                # Handle the socket with the next soonest event (by EVENT_TS)
                next_socket = sorted(next_events.items(), key = lambda x: x[1][c.EVENT_TS])[0][0]
                next_event = next_events.pop(next_socket)        # remove the event from next_events
                # tick the clock if it has a larger timestamp than the current clock (not a late-arriving event)
                if (tempts := next_event[c.EVENT_TS]) > self.clock:
                    self.clock = tempts

                self._handle_event(next_event)

    def shutdown(self):
        """Set the shutdown flag and close the sockets.
        """        
        self.shutdown_flag.set()
        for socket in [self.data_socket, self.order_socket, self.logging_socket]:
            socket.close(linger = 10)